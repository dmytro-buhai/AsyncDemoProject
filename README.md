# AsyncDemoProject

## ILSpy Decompiled Code Example

This code demonstrates the "Lowered" code (State Machine) generated by the Roslyn compiler for an `async` method.

```csharp
// AsyncDemoProject, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// AsyncDemoProject.Program.<Main>d__0
using System;
using System.Diagnostics;
using System.Net.Http;
using System.Runtime.CompilerServices;

[CompilerGenerated]
private sealed class <Main>d__0 : IAsyncStateMachine
{
    // Tracks the current state of execution:
    // -1 = Start / Running
    //  0 = Paused at first await
    //  1 = Paused at second await
    // -2 = Finished
    public int <>1__state;

    // The builder that creates and manages the Task returned to the caller
    public AsyncTaskMethodBuilder <>t__builder;

    // "Lifted" argument from the original method
    public string[] args;

    // "Lifted" local variables (saved here to survive the pause)
    private HttpClient <client>5__1;
    private string <task>5__2;
    private int <a>5__3;
    private string <task2>5__4;
    private string <>s__5;
    private int <i>5__6;
    private string <>s__7;
    private TaskAwaiter<string> <>u__1;

    private void MoveNext()
    {
        // 1. LOAD STATE
        // When first called by Start(), this is -1.
        int num = <>1__state; 

        try
        {
            TaskAwaiter<string> awaiter;
            TaskAwaiter<string> awaiter2;

            if (num != 0)
            {
                if (num == 1)
                {
                    // We are resuming from the second await (State 1)
                    awaiter = <>u__1;
                    <>u__1 = default(TaskAwaiter<string>);
                    num = (<>1__state = -1);
                    goto IL_014f;
                }

                // --- START OF METHOD (State -1) ---
                
                // Initialize local variable
                <client>5__1 = new HttpClient();
                
                // Start the async operation
                awaiter2 = <client>5__1.GetStringAsync("[https://google.com](https://google.com)").GetAwaiter();

                // --- FAST PATH OPTIMIZATION ---
                // "Did the task finish instantly?"
                // If true: We skip the block below and continue synchronously (huge performance win).
                // If false: We must pause execution.
                if (!awaiter2.IsCompleted)
                {
                    // 1. SAVE THE GAME
                    // Mark state as 0. 
                    // When MoveNext() is called again, it will start at the top, read this 0, 
                    // and immediately jump to the 'else' block (skipping the code above).
                    num = (<>1__state = 0);
                    
                    // Save the awaiter so we can get the result later
                    <>u__1 = awaiter2;

                    // 2. SET THE ALARM CLOCK
                    // Tell the builder: "Call MoveNext() when this task finishes"
                    <Main>d__0 stateMachine = this;
                    <>t__builder.AwaitUnsafeOnCompleted(ref awaiter2, ref stateMachine);

                    // 3. QUIT (YIELD THE THREAD)
                    // The thread returns to the pool to do other work.
                    // When this method returns, the thread that was running this code is freed and goes back to the Thread Pool to handle other requests.
                    return;
                }
            }
            else
            {
                // --- RESUMING FROM STATE 0 ---
                // We land here when the callback triggers MoveNext() // <-- QUESTION: When MoveNext() is getting called again?

                // 1. RETRIEVE THE TOOL (Restore the Awaiter)
                // When we paused, we saved the awaiter into the field '<>u__1' so it wouldn't be lost.
                // Now we pull it back into the local variable 'awaiter2' so we can check the result.
                awaiter2 = <>u__1;

                // 2. CLEANUP (Prevent Memory Leaks)
                // We set the class field to 'default' (null/zero).
                // Why? If we don't clear this field, the State Machine keeps a reference to the Task 
                // forever, which stops the Garbage Collector from cleaning up memory.
                <>u__1 = default(TaskAwaiter<string>);

                // 3. RESET STATE (Back to Running)
                // We set state back to -1 ("Running").
                // This means we are no longer "waiting" for this specific task. 
                // We are actively processing again.
                num = (<>1__state = -1);
            }

            // Get the result (either from Fast Path or after Resume)
            <>s__5 = awaiter2.GetResult();
            <task>5__2 = <>s__5;
            <>s__5 = null;
            
            // Synchronous CPU work
            <a>5__3 = 0;
            <i>5__6 = 0;
            while (<i>5__6 < 1000000)
            {
                <a>5__3 = <i>5__6 + 1;
                <i>5__6++;
            }

            // Second async operation
            awaiter = <client>5__1.GetStringAsync("[https://google.com](https://google.com)").GetAwaiter();
            if (!awaiter.IsCompleted)
            {
                // Pause for State 1
                num = (<>1__state = 1);
                <>u__1 = awaiter;
                <Main>d__0 stateMachine = this;
                <>t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);
                return;
            }
            goto IL_014f;

            IL_014f:
            // --- RESUMING FROM STATE 1 ---
            <>s__7 = awaiter.GetResult();
            <task2>5__4 = <>s__7;
            <>s__7 = null;
            
            Console.WriteLine("Hello World");
        }
        catch (Exception exception)
        {
            // Handle Exceptions
            <>1__state = -2;
            <client>5__1 = null;
            <task>5__2 = null;
            <task2>5__4 = null;
            <>t__builder.SetException(exception);
            return;
        }

        // --- COMPLETION ---
        <>1__state = -2;
        <client>5__1 = null;
        <task>5__2 = null;
        <task2>5__4 = null;
        <>t__builder.SetResult(); // Mark task as successfully completed
    }

    void IAsyncStateMachine.MoveNext()
    {
        this.MoveNext();
    }

    [DebuggerHidden]
    private void SetStateMachine(IAsyncStateMachine stateMachine)
    {
    }

    void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
    {
        this.SetStateMachine(stateMachine);
    }
}

```

<details>
  <summary>Click to reveal the answer on the question "When we landing into the else block?"</summary>
  
  After the Network Card receives the data packet! Here is the step-by-step logic of what happens when the thread wakes up and runs `MoveNext()` for the second time (the Resume).
  
  1.  **The Trigger:** The Thread Pool grabs a free thread and executes `MoveNext()`.
  2.  **Line 1:** `int num = <>1__state;`
      * *Action:* It reads the value `0` from the class field in memory (because we saved `0` before we quit last time).
  3.  **Line 2:** `if (num != 0)`
      * *Question:* Is `0` not equal to `0`?
      * *Answer:* **False**.
  4.  **The Result:** Because the condition is false, it **skips the entire `if` block**.
      * It drops strictly into the `else` block.
  
</details>

## "Then who is actually doing the work?"

It seems like the code is just running back and forth, waiting for `if awaiter2.IsCompleted` to become true. Who does the work while we wait?

**The Answer:** This is the most common "aha!" moment in understanding async. **No one is "doing the work" in C# code while the download happens.** And definitely no one is running back and forth checking the status.

Here is the shocking truth: **The thread is gone.** It left. It went to serve another user. Your function is effectively "dead" in memory.

So who downloads the data? **The Network Card (Hardware).**

### Step-by-Step Reality

1.  **The Setup (You / The CPU)**
    When your code runs `client.GetStringAsync(...)`, your thread sends a command to the Operating System (Windows/Linux) saying: *"Hey, open a socket and get data from Google."* The OS passes this order to the Network Interface Card (NIC) driver.

2.  **The "Pause" (The Magic Trick)**
    This is where confusion often arises. The code checks `IsCompleted` **exactly once**.
    * It sees `false` (not done).
    * It tells the Task: *"Here is my phone number (continuation). Call me when you are done."*
    * It **RETURNS**. The C# thread walks away.
    * *At this specific moment, ZERO threads in your application are working on this request.*

3.  **The "Work" (The Hardware)**
    While your application is silent:
    * The **Network Card** sends electrical signals down the wire/Wi-Fi.
    * It waits for Google to send electrons back.
    * This wait costs **0% CPU**. It is pure hardware waiting on physics.

4.  **The "Wake Up" (The Interrupt)**
    * The Network Card receives the data packet.
    * It fires a **Hardware Interrupt** to the CPU.
    * The OS sees the packet is complete and finds the Task associated with it.
    * The OS says: *"Okay, the data is ready. Who was waiting for this?"*
    * It finds your callback (the `MoveNext` method) and posts a job to the Thread Pool.

5.  **The Resume (A "New" Thread)**
    A random thread from the Thread Pool (it might be a different thread than the one you started with!) picks up the job. It calls `MoveNext()`. Inside `MoveNext`, it jumps to the `else` block (Restoration), picks up the `awaiter` (which now has the data), and your code continues.



### The Pizza Analogy
To visualize why it's not "running back and forth":

* **You (The Thread)** order a pizza at the counter.
* **The Cashier (The OS)** gives you a **Pager** (The `Task`).
* **You leave the counter** and sit down to check Instagram (You are free!). You do not stand there asking "Is it ready?" every second.
* **The Chef (The Hardware)** bakes the pizza. You aren't baking it. The cashier isn't baking it. The oven is baking it.
* **BZZZT!** The pager vibrates.
* **You (or your friend)** goes back to the counter to pick it up.

### Summary
* **Is it looping?** No. It checks once and quits.
* **Who is waiting?** The hardware device (Network Card).
* **Who is working?** No one (CPU-wise). The computer is free to do other things.
